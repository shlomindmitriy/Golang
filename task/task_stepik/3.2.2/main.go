package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"strings"
)

/*
Для решения данной задачи вам понадобится пакет strconv, возможно использовать пакеты strings или encoding/csv, или даже bufio - вы не ограничены в выборе способа решения задачи. В решениях мы поделимся своими способами решения этой задачи, предлагаем вам сделать то же самое.
В привычных нам редакторах электронных таблиц присутствует удобное представление числа с разделителем разрядов в виде пробела, кроме того в России целая часть от дробной отделяется запятой. Набор таких чисел был экспортирован в формат CSV, где в качестве разделителя используется символ ";".
На стандартный ввод вы получаете 2 таких вещественных числа, в качестве результата требуется вывести частное от деления первого числа на второе с точностью до четырех знаков после "запятой" (на самом деле после точки, результат не требуется приводить к исходному формату).
P.S. небольшое отступление, связанное с чтением из стандартного ввода. Кто-то захочет использовать для этого пакет bufio.Reader. Это вполне допустимый вариант, но если вы резонно обрабатываете ошибку метода ReadString('\n'), то получаете ошибку EOF, а точнее (io.EOF - End Of File). На самом деле это не ошибка, а состояние, означающее, что файл (а os.Stdin является файлом) прочитан до конца. Чтобы ошибка была обработана правильно, вы можете поступить так:

if err != nil && err != io.EOF {
	...
}
Sample Input:
	1 149,6088607594936;1 179,0666666666666
Sample Output:
	0.9750
*/

func main() {
	var str string

	str, _ = bufio.NewReader(os.Stdin).ReadString('\n')
	str = strings.Trim(str, "\n")
	mas := []rune(str)

	for i := 0; i < len(mas); i++ {
		if mas[i] == ',' {
			mas[i] = '.'
		}
	}

	s := strings.ReplaceAll(string(mas), " ", "")
	a := strings.Split(s, ";")
	
	b := make([]string, 0)
	b = append(b, a[0])
	f := strings.Join(b, "")

	result1, err := strconv.ParseFloat(f, 64)
	if err != nil {
		panic(err)
	}

	c := make([]string, 0)
	c = append(c, a[1])
	n := strings.Join(c, "")

	result2, err := strconv.ParseFloat(n, 64)
	if err != nil {
		panic(err)
	}

	rezz := result1 / result2
	fmt.Printf("%.4f", rezz)
}
